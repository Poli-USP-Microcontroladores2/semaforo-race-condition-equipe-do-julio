ATIVIDADE - Race Condition

O prompt utilizado está copiado abaixo. Anexou-se um arquivo de exemplo, com o código desenvolvido na atividade de Prioridades, para demonstrar o uso de logging para imprimir as informações e as mudanças de sintaxe trazidas com a nova versão do Zephyr, além de diminuir a chance de erros da IA com essas questões. Tentou-se ser o mais específico possível, para evitar de criar dois exemplos totalmente diferentes a cada vez, mas ainda deixando liberdade para criação.

Prompt:
“Estou estudando sobre Race Condition, usando o microcontrolador FRDM-KL25Z, no VSCode, usando o Zephyr IDE no platformIO, na versão 3.40200.0. Crie um código (equivalente ao arquivo main.c do platformIO) que exemplifica esse fenômeno, com duas threads que controlam um mesmo LED e utilizam uma mesma variável global que define o estado da LED. Use logs de informação (LOG_INF) para imprimir informações estratégicas para demonstrar o problema. Use o código anexado como exemplo para montar o código.
Código anexado:
	#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/printk.h>
#include <zephyr/device.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(meu_modulo, LOG_LEVEL_INF);

// LEDs e Botão
#define LED_C_NODE DT_ALIAS(led1)
#define LED_A_NODE DT_ALIAS(led0)  // LED verde
#define BUTTON_NODE DT_NODELABEL(user_button_0)

static const struct gpio_dt_spec ledA = GPIO_DT_SPEC_GET(LED_A_NODE, gpios);
static const struct gpio_dt_spec ledc = GPIO_DT_SPEC_GET(LED_C_NODE, gpios);
static const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(BUTTON_NODE, gpios);
static struct gpio_callback button_cb_data;

#define PRIO_THREAD_A 5   // Maior prioridade (número menor)
#define TEMPO_A_MS   500   // Thread A dorme

// ISR - Toggle LED
void button_isr(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    LOG_INF ("Interrompeu!\n");
    gpio_pin_toggle_dt(&ledc);
}

void thread_A(void *p1, void *p2, void *p3)
{
    while (1) {
        int startA = k_uptime_get();
        LOG_INF("Começo do ciclo de A: %d ms\n", startA);
        gpio_pin_set_dt(&ledA, 1);  // Liga LED verde

        // Simula processamento rápido 
        for (volatile int i = 0; i < 10000000; i++) {}

        gpio_pin_set_dt(&ledA, 0);  // Desliga LED verde
        
        int endA = k_uptime_get();
        LOG_INF("Tempo da Thread A: %d ms\n", (endA-startA));
        LOG_INF("Fim do ciclo de A: %d ms\n", endA);
   
        k_msleep(TEMPO_A_MS);       // Dorme — libera CPU
    }
}

    K_THREAD_DEFINE(a_tid, 512, thread_A, NULL, NULL, NULL,
                PRIO_THREAD_A, 0, 0);

void main(void)
{
    // Configurar LED e botão com pull-up
    gpio_pin_configure_dt(&ledc, GPIO_OUTPUT_INACTIVE);
    gpio_pin_configure_dt(&button, GPIO_INPUT | GPIO_PULL_UP);

    if (!device_is_ready(ledA.port)) {
        return;
    }
    gpio_pin_configure_dt(&ledA, GPIO_OUTPUT_INACTIVE);
    
    // Configurar interrupção na borda de descida
    gpio_pin_interrupt_configure_dt(&button, GPIO_INT_EDGE_FALLING);
    gpio_init_callback(&button_cb_data, button_isr, BIT(button.pin));
    gpio_add_callback(button.port, &button_cb_data);

    LOG_INF("Thread A (verde): prioridade %d\n", PRIO_THREAD_A);
    
    // Main dorme
    while (1) {
        k_sleep(K_FOREVER);
    }
} “

O exemplo real utilizado e especificado no prompt é o uso de uma mesma variável global por duas threads distintas paralelamente, nesse caso, para controlar o estado de um mesmo LED. Com isso, o comportamento do LED torna-se instável e imprevisível, devido ao fenômeno de Race Condition. Dessa forma, o LED pisca em períodos aleatórios.
Com esse prompt, a IA fornece um código que exemplifica esse fenômeno, com sleep times e outras características arbitrárias, variando de IA para IA. Além disso, é fornecido uma explicação do fenômeno e, às vezes, como corrigi-lo.
O prompt foi testado em três IA’s diferentes, nesta ordem: Chat GPT, Gemini e Copilot. Os três forneceram códigos similares que exemplificam o problema da forma que foi pedida.